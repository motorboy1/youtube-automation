​

## 📌 문서만 넣으면 AI가 대신 답하는 RAG Agent를 15분 만에 만드는 방법은?
 n8n과 슈퍼베이스를 활용하여 문서를 벡터 데이터베이스에 저장하고, 이를 기반으로 ai 에이전트가 질문에 답변하도록 구축할 수 있습니다.


## 💡 RAG Agent의 핵심 원리는 무엇인가?
 사용자가 제공한 문서를 검색(Retrieval)하여 AI가 더 정확하고 향상된 답변을 생성(Generation)하는 것입니다. 


문서의 방대함 때문에 원하는 정보를 찾기 어려웠던 분들을 위해, 이 콘텐츠는 **rag****(검색 증강 생성) 에이전트**를 **15분 만에** 구축하는 실용적인 방법을 제시합니다. n8n과 슈퍼베이스(Supabase)를 활용하여 회사 취업 규칙이나 고객 응대 매뉴얼 같은 내부 문서를 AI가 대신 읽고 정확하게 답변하게 만드는 **업무 ****자동화**** 시스템**을 직접 구축할 수 있습니다. 이 가이드를 통해 AI가 단순한 대화 상대를 넘어, **내부 지식을 기반으로 맥락에 맞는 답변**을 생성하는 강력한 업무 도구로 변모하는 과정을 경험하고 즉시 업무에 적용해 보세요.
## 1. RAG(검색 증강 생성) 에이전트의 개념 및 필요성 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/N6Ual_n9SaQ/0.jpg)
1. **RAG**** 에이전트의 필요성**:
  1. 회사 내 방대한 문서에서 원하는 정보를 찾기 어렵거나, 매뉴얼 기반 업무 시 답변에 시간이 오래 걸리는 문제를 해결할 수 있다 
  2. RAG 에이전트를 제작하면 AI가 문서를 대신 읽고 정확하게 답변을 해 줄 수 있다 
  3. n8n을 활용하면 간단한 RAG 에이전트를 <mark>15분 만에</mark> 완성할 수 있다 

2. **RAG****의 정의 및 구조**:
  1. RAG는 **R**etrieval **A**ugmented **G**eneration의 줄임말이다 
  2. RAG는 제공된 문서를 <em>retriever</em>(검색)하여 더 정확하고 향상된 답변을 <em>generation</em>(생성)해 주는 구조이다 
  3. RAG는 내 업무와 관련된 구체적인 질문에 답변하지 못했던 기존 AI의 단점을 해결할 수 있다 

3. **RAG****의 작동 순서 (문서 업데이트 단계)**:
  1. **문서 준비**: 다양한 형식의 문서를 준비한다 
  2. **청크**** 분할**: 문서를 문단이나 문장 단위로 **청크**로 쪼갠다 
  3. **임베딩 변환 (벡터화)**: 쪼개진 청크를 임베딩 모델을 통해 **벡터 형태의 숫자**로 변환한다 
  1. 임베딩은 문서 내용이 질문 내용과 얼마나 관련되어 있는지 평가하는 알고리즘을 활용하기 위해 필요한 작업이다 
  4. **데이터베이스**** 저장**: 벡터 형태로 변환된 데이터를 **벡터 데이터베이스**에 업데이트하여 저장한다 

4. **RAG****의 작동 순서 (질문 및 답변 생성 단계)**:
  1. **질문 벡터화**: 사용자의 질문 내용을 다시 임베딩 모델을 통해 벡터화한다 
  2. **유사 ****청크**** 검색**: 벡터화된 질문을 데이터베이스에 있는 문서 내용(벡터)과 비교하여 유사한 청크를 판별해 낸다 
  3. **답변 생성**: 판별된 청크들을 가져와 질문 내용과 합친 후, LLM 모델에 넣어 맥락에 맞는 답변을 생성한다 

5. **RAG**** 사용의 이점**:
  1. 문서 전체를 AI에게 던져줄 경우 컨텍스트 리밋을 넘거나 답변 퀄리티가 떨어질 수 있다 
  2. RAG는 질문과 관련된 내용만 읽고 답변하여 전체 문서를 읽는 것보다 더 빠르고 효율적이다 


## 2. RAG 에이전트 제작 환경 설정 (Supabase 활용) 


### 2.1. Supabase 프로젝트 생성 및 벡터 데이터베이스 준비 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/N6Ual_n9SaQ/180.jpg)
1. **벡터 데이터베이스**** 선택**:
  1. RAG를 구현하려면 문서를 저장할 데이터베이스가 필요하며, 여기서는 **Supabase** 서비스를 활용한다 
  2. Supabase는 초보자도 쉽게 활용 가능하며, 벡터 데이터베이스뿐만 아니라 PostgreSQL과 연동된 관계형 데이터베이스도 제공하는 유용한 서비스이다 
  3. Supabase는 무료로도 활용할 수 있다 

2. **Supabase 프로젝트 생성**:
  1. Supabase.com에 접속하여 로그인 후, 'New Project'를 선택한다 
  2. 프로젝트 이름은 'RAG Agent' 등으로 지정하고, 데이터베이스 비밀번호를 설정한다 (비밀번호는 반드시 기억해야 한다) 
  3. 리전(Region)은 서울로 선택하고 프로젝트를 생성한다 

3. **벡터 데이터베이스**** 테이블 생성**:
  1. Supabase 프로젝트 내에 테이블을 생성해야 n8n에서 활용할 수 있다 
  2. Supabase의 가이드 문서(Docs)에서 'Quickstart: Setting up your vector store' 옵션을 찾아 SQL 코드를 복사한다 
  3. Supabase의 SQL 에디터에 복사한 코드를 붙여 넣고 실행한다 
  1. **SQL**** 코드의 역할**:
  1. 첫 번째: 임베딩 변환 작업에 필요한 pg_vector 익스텐션을 추가한다 
  2. 두 번째: documents라는 이름의 테이블을 생성하는 SQL 명령어이다 
  3. **임베딩 벡터 차원 설정**: 테이블 생성 시 embedding vector의 차원을 <mark>1536</mark>으로 설정하는데, 이는 OpenAI의 임베딩 스몰 모델이 1536차원의 벡터를 생성하기 때문이다 
  4. 세 번째: 관련된 문서 내용을 검색해 주는 match_documents 함수를 추가한다 
  4. 실행 후 'Success'가 뜨면 테이블 생성이 완료되며, 테이블 에디터에서 documents 테이블이 생성된 것을 확인할 수 있다 


## 3. n8n 워크플로우 구축 (문서 업로드 자동화) 


### 3.1. 구글 드라이브 파일 다운로드 설정 
![image]()
1. **워크플로우**** 목표**: 구글 드라이브 특정 폴더에 파일이 생성되면 자동으로 Supabase에 업데이트되도록 설정한다 
2. **Google Drive 트리거 노드 추가**:
  1. Google Drive 노드를 추가하고, 트리거로 'On change involving a specific folder'를 선택한다 (폴더에 파일이 생성되었을 때를 감지) 
  2. 구글 계정을 연동한다 
  3. 폴더 체크 주기를 설정한다 (예: 매분 체크) 
  4. 파일을 감시할 폴더를 설정한다 (예: NAM 프로젝트 폴더) 
3. **테스트 파일 추가 (****취업 규칙****)**:
  1. 가상의 회사(구시 컴퍼니)에서 직원들이 취업 규칙 관련 질문에 쉽게 답변을 받을 수 있는 AI 에이전트를 만들고자 한다고 가정한다 
  2. 취업 규칙 내용이 담긴 구글 독스 파일(27장 분량)을 설정된 폴더(NA 프로젝트)로 이동시킨다 
  3. 트리거를 실행하여 파일 값을 가져온다 
4. **Google Drive 다운로드 노드 추가**:
  1. Google Drive 노드를 추가하고 오퍼레이션을 'Download File'로 선택한다 
  2. 다운로드할 파일의 ID 값을 이전 트리거 노드에서 가져와 매핑한다 
  3. 노드를 실행하면 구시 컴퍼니의 취업 규칙 내용이 다운로드된다 


### 3.2. Supabase 벡터 스토어 업데이트 설정 
![image]()
1. **Supabase Vector Store 노드 추가**:
  1. 노드를 추가하고 'Supabase Vector Store'를 검색하여 선택한다 
  2. 오퍼레이션은 'Add Document'를 선택한다 
2. **Supabase 계정 연동**:
  1. 'Create New Credential'을 선택하고 호스트(Host)와 시크릿(Secret) 값을 입력해야 한다 
  2. Supabase 프로젝트 설정(Project Settings)의 'Database API' 옵션에서 프로젝트 URL(Host URL)을 가져온다 
  3. API 키 섹션에서 'Service Role Secret' 값을 리빌(Reveal)하여 시크릿 값으로 복사 붙여넣기 한다 
3. **테이블 및 ****청크**** 설정**:
  1. 연결이 완료되면 테이블 목록에서 생성해 둔 documents 테이블을 선택한다 
  2. **임베딩 배치 사이즈**: 청크를 벡터 스토어에 업데이트할 때 한 번에 변환할 청크의 개수를 설정하며, 기본값인 <mark>200</mark>으로 둔다 
4. **문서 ****청크**** 및 스플리팅 설정**:
  1. 벡터 데이터베이스에 업데이트하기 전에 문서를 청크로 나누는 작업이 필요하다 
  2. 'Document' 옵션에서 'Default Data Loader'를 선택한다 
  3. **데이터 타입**: 취업 규칙 파일이 바이너리 파일로 들어왔으므로 'Type Data'를 'Binary'로 선택하고 전체 데이터를 로드한다 
  4. **텍스트 스플리팅**** 옵션**: 청크를 나누는 방식을 설정한다 
  1. 'Simple'은 1,000개 문자 단위로 쪼개고 200개 문자마다 오버랩을 시켜주는 방식이다 
  2. **추천 방식**: 'Custom'을 선택하고 'Recursive Character Text Splitter'를 활용하는 것이 추천된다 
  - 이 방식은 문단, 문장, 단어 순으로 글의 흐름을 고려하여 센스 있게 잘라주는 스플리터이다 
  3. 청크 사이즈는 디폴트 값으로 둔다 
5. **메타데이터**** 추가**:
  1. 문서 내용을 청크로 나누면 부분별로만 저장되므로, 해당 부분에 대한 추가 설명(메타데이터)을 같이 저장할 수 있다 
  2. 여러 파일을 동일 테이블에 추가할 수 있으므로, 파일 이름을 메타데이터로 추가한다 
  3. 메타데이터의 이름은 'Document Title'로 하고, 값은 스키마에서 파일 이름(File Name)을 매핑한다 
6. **임베딩 모델**** 설정**:
  1. 청크된 문서를 벡터 형태로 변환하기 위해 **OpenAI 모델**을 활용한다 
  2. OpenAI API 키를 생성하여 인증을 완료한다 
  3. 모델은 text-embedding-3-small을 선택한다 
7. **업데이트 실행 및 확인**:
  1. 워크플로우를 실행하면 청크 및 임베딩 과정을 거쳐 Supabase에 업데이트된다 
  2. 실행 결과, 21개 아이템으로 나뉘어 저장된 것을 확인한다 
  3. Supabase의 documents 테이블에서 데이터가 나뉘어 들어갔는지, 메타데이터에 'Document Title'이 포함되었는지, 임베딩 섹션에 벡터 값이 잘 들어갔는지 확인한다 


## 4. RAG 기반 AI 에이전트 제작 및 테스트 


### 4.1. AI 에이전트 기본 설정 및 시스템 프롬프트 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/N6Ual_n9SaQ/771.jpg)
1. **AI 에이전트**** 노드 추가**:
  1. 새로운 노드로 'Trigger On Chat Message'를 선택하고, 이어서 'AI Agent' 노드를 추가한다 
2. **시스템 메시지 설정**:
  1. 시스템 프롬프트에 다음과 같은 지침을 설정한다 
  1. 한국어로 된 다큐먼트를 참고해서만 항상 답변할 것
  2. 질문 내용에 대한 정보를 찾을 수 없으면 "해당 문서에는 정보가 없습니다"라고 답변할 것
  3. 항상 답변은 한글로 답변할 것 
3. **모델 설정**:
  1. AI 에이전트가 답변을 해 줄 모델로 **OpenAI의 ****GPT-4****o**를 활용하도록 설정한다 


### 4.2. 툴 설정 (Supabase 벡터 스토어 연동) 
![image]()
1. **툴 추가**:
  1. 툴 설정에서 Supabase를 선택하고 'Supabase Vector Store'를 선택한다 
  2. 오퍼레이션 모드는 AI 에이전트의 툴로서 문서를 검색하는 기능인 'Retrieve Documents'가 맞다 
2. **툴 상세 설정**:
  1. **Description**: AI 에이전트가 검색에 참고할 수 있도록 "회사 관련된 내용을 검색할 수 있는 툴"이라고 설명을 적어준다 
  2. **Table**: documents 테이블을 선택한다 
  3. **Include Metadata**: 메타데이터(Document Title)를 넣어줬으므로 포함하도록 설정한다 
  4. **Limit**: 가져올 관련된 청크의 개수를 설정하며, 기본값인 <mark>4</mark>로 설정한다 
3. **툴 ****임베딩 모델**** 설정**:
  1. 질문을 벡터로 변환해야 하므로, Supabase Vector Store 툴에도 임베딩 모델을 설정해야 한다 
  2. **중요**: 문서를 넣을 때 활용했던 임베딩 모델(text-embedding-3-small)과 **동일한 모델**을 선택해야 정확하게 비교할 수 있다 


### 4.3. 메모리 설정 (Postgres Chat Memory) 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/N6Ual_n9SaQ/887.jpg)
1. **메모리 필요성**: 메모리 설정을 하면 AI 에이전트가 대화 내용을 기억하여 컨텍스트를 이해하고 답변할 수 있다 
2. **Postgres Chat Memory 활용**:
  1. 대화 내용을 아카이브하고 확인하고 싶을 경우, Supabase가 내장하고 있는 PostgreSQL을 통해 'Postgres Chat Memory'를 활용할 수 있다 
  2. 메모리 유형으로 'Postgres Chat Memory'를 선택한다 
3. **Postgres 연결 설정**:
  1. Supabase 프로젝트에서 'Connect' 버튼을 누르고 'Transaction Pool'에 뜨는 값들을 활용하여 계정을 생성한다 
  2. 호스트, 포트, 유저 값을 변경하고 비밀번호는 프로젝트 생성 시 설정한 비밀번호를 넣어 연결을 완료한다 
4. **메모리 저장 및 윈도우 설정**:
  1. 연결 후, n8n_chat_messages라는 테이블로 메모리에 들어오는 채팅 내용을 저장하게 된다 
  2. **Context Window Length**: AI 에이전트가 기억하고 활용할 대화 개수를 설정하며, <mark>5</mark>로 설정한다 


### 4.4. 취업 규칙 기반 테스트 및 검증 
![image]()
1. **테스트 준비**:
  1. 챗을 열어 메시지를 보내면, Supabase에 n8n_chat_messages 테이블이 추가되고 질문과 답변이 저장되는 것을 확인한다 
2. **겸업**** 관련 질문 테스트**:
  1. 질문: "구시 컴퍼니 겸업 관련 조항이 어떻게 되는지" 
  2. **답변**: "임직원은 회사의 사전 승인 없이 다른 직업에 종사할 수 없다"는 내용과 함께 겸업 금지되는 경우, 승인 가능한 예시(학술 연구 활동, 강의, 부동산 임대업, 재능 기부 등)를 정확히 설명해 준다 
  3. **프로세스 확인**: AI 에이전트 노드의 로그를 확인하면, 질문을 기반으로 검색하여 겸업 관련 내용이 담긴 <mark>네 개의 </mark>청크를 가져와 답변에 참고했음을 확인할 수 있다 
3. **연차**** 사용 관련 질문 테스트**:
  1. 질문: "입사한지 6개월이 안 되었는데 연차 사용이 가능한가요?" 
  2. **답변**: "1개월 개근 시 1일의 연차가 부여되며, 월차는 발생한 당월 내에 사용하는 것이 원칙"이므로, 6개월 미만 재직자도 매달 1일씩 발생하는 월차를 사용할 수 있다고 정확히 답변한다 
4. **출퇴근 시간 관련 질문 테스트**:
  1. 질문: "출퇴근 시간은 어떻게 되는지" 
  2. **답변**: 부서별로 다를 수 있다고 설명하며, 고객 지원팀으로 검색했을 때 부서별로 나눠진 표준 근무 시간 내용을 잘 알려준다 


## 5. 추가 문서 업로드 및 CS 에이전트 테스트 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/N6Ual_n9SaQ/1122.jpg)
1. **CS 에이전트**** 구축 목표**: 신입사원도 고객 응대를 손쉽게 할 수 있도록 고객 응대 매뉴얼을 넣어두고, 신입사원이 에이전트에게 질문하며 답변할 수 있도록 돕는 CS 에이전트를 만든다 
2. **새로운 문서 업로드**:
  1. 이번에는 PDF 파일 포맷으로 제작된 고객 응대 매뉴얼을 준비한다 
  2. 해당 PDF 파일을 n8n 폴더로 추가한다 
  3. 기존 취업 규칙 파일은 테스트 동안 이동시켜 둔다 
3. **워크플로우**** 실행 및 확인**:
  1. 테스트를 실행하면 매뉴얼 문서가 들어오고 다운로드된다 
  2. 워크플로우를 실행하여 벡터 데이터베이스에 청크를 내서 업데이트한다 
  3. Supabase documents 테이블에서 매뉴얼 가이드 내용이 들어왔고, 다큐먼트 타이틀도 확인된다 
4. **CS 관련 질문 테스트 (****환불****)**:
  1. 챗을 열어 새로운 세션을 시작한다 
  2. 질문: "고객이 배송 지연으로 환불을 요구할 때 어떻게 응대하도록 되어 있는지" 
  3. **답변**: 환불 의사 확인 및 처리 방법, 환불에 따른 금액 계산 및 안내 등 관련 내용을 생성해 준다 
5. **CS 관련 질문 테스트 (불만 응대)**:
  1. 질문: "고객이 상품의 불만을 표현할 때 첫 응대는 어떻게 해야 하는지, 그리고 상황에 따라 적절한 해결책을 전체 단계로 알려달라" 
  2. **답변**: 1단계부터 5단계까지의 조치 방법을 잘 알려준다 
6. **에이전트 공유 및 활용**:
  1. RAG 에이전트를 여러 명이 같이 활용하고 싶다면, 챗 UI에서 'Publicly Available' 설정을 통해 URL로 활용할 수 있다 
  2. 슬랙 등 다른 서비스와 연동하여 봇으로 연결해 활용할 수도 있다 


## 6. RAG 에이전트의 한계점 및 추가 고려 사항 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/N6Ual_n9SaQ/1238.jpg)
1. **RAG**** 에이전트의 한계점**:
  1. 현재 제작된 RAG 에이전트는 간단한 버전이므로 분명한 한계점이 존재한다 
  2. **키워드 기반 질문의 어려움**: RAG는 관련 있는 청크를 가져와 답변하는 구조이므로, 특정 모델의 규격, 사이즈, 색상 등 키워드 기반 질문에 대해서는 답변을 잘 해 주지 못하는 단점이 있다 
  3. **요약 작업의 어려움**: 문서의 일부분만 발췌하여 답변하는 구조이므로, 전체 문서를 요약하는 작업은 잘 하지 못한다 
  4. **계산 및 분석 작업의 어려움**: 관련 정보를 파악하고 답변하는 것이 주 기능이므로, 스프레드시트 같은 테이블에 들어있는 숫자를 계산하거나 분석하는 작업도 잘 수행하지 못한다 
2. **해결 방안**: 위와 같은 작업들이 주를 이룬다면 RAG를 하는 방식을 더 커스텀해야 한다 
3. **마무리**: n8n과 Supabase를 활용하면 복잡하게 느껴지는 RAG 에이전트를 손쉽게 만들고 활용할 수 있다 

